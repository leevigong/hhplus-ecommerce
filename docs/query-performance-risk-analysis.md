# 조회가 오래 걸릴 수 있는 기능 분석 보고서

> ⚠️ 아래 기능들은 대용량 데이터에 필터링·정렬·집계가 동반되어 **조회 성능 저하** 위험이 큽니다.  

---

## 1. 인기 판매 상품 조회 (최근 3일간 TOP5)

#### 문제가 되는 이유
  - 단일 쿼리로 `orders` ↔ `order_item` JOIN, `GROUP BY`, `ORDER BY`를 동시에 수행할 때, 데이터가 누적될수록 전체 스캔 및 정렬 비용이 기하급수적으로 증가합니다.
  - 실시간 요청 트래픽이 몰리면 CPU·메모리 부하가 집중되어 쿼리 지연 및 타임아웃 가능성이 높아집니다.


#### 리서치한 기술·솔루션

| 방식                         | 장점                                                               | 단점                                                                              |
|----------------------------|------------------------------------------------------------------|---------------------------------------------------------------------------------|
| **실시간 JOIN 조회**            | • 구현이 간단<br>• 실시간 정확도 100%                                  | • 대량 데이터시 전체 스캔으로 성능 급감<br>• 복잡한 그룹·정렬로 DB 부하 집중            |
| **주문 시점마다 통계 테이블 업데이트**    | • 실시간으로 집계 유지<br>• 조회 시 단순 조회만 수행                       | • 주문마다 쓰기 부하 발생<br>• 동시성 이슈(락/락버전) 관리 필요<br>• 코드·인프라 복잡도 증가 |
| **스케쥴러(배치) 집계 테이블**        | • 배치 시 고비용 집계 → 조회 시 인덱스 스캔만 수행<br>• 읽기 부하 최소화     | • 배치 실패 시 데이터 불일치 위험                            |
| **Redis 캐시**               | • 메모리 조회로 초저지연 응답<br>• TTL 설정으로 갱신 주기 관리 가능        | • DB-캐시 일관성 문제 가능<br>• 캐시 무효화 전략·운영 복잡도 증가                     |
| **CQRS + 이벤트 기반 비동기 업데이트** | • 읽기/쓰기 분리로 확장성 우수<br>• 이벤트 스트림으로 실시간 집계 가능     | • 초기 설계·운영 복잡도 높음<br>• 메시지 브로커·읽기 전용 저장소 운영 필요<br>• 동기화 검증 로직 필요 |

> ➡️ **최종 선택**  
> • **스케쥴러 집계 테이블**을 사용해 매일 자정에 통계 테이블을 일괄 계산합니다.  
> • 조회 시 이미 계산된 테이블을 활용하므로 응답 속도가 크게 향상됩니다.  
> • 향후 실시간성이 추가로 요구되면 캐시 도입을 검토합니다.
---

## 2. 상품 목록 조회 (필터·페이징)

#### 문제가 되는 이유
  - 전체 `Product` 테이블을 풀 스캔해야 하므로 정렬 비용이 급격히 증가합니다.
  - OFFSET 기반 페이징은 페이지가 깊어질수록 버퍼링되는 레코드가 많아져 응답 지연이 발생합니다.

#### 리서치한 기술·솔루션

| 방식                      | 장점                                                         | 단점                                                         |
|-------------------------|------------------------------------------------------------|------------------------------------------------------------|
| **단일 인덱스 + OFFSET 페이징** | • 구현이 가장 단순, 기존 쿼리 수정 거의 없음 | • OFFSET·정렬 비용이 페이지 깊이에 비례해 증가 → 데이터가 많아질수록 급격히 느려짐 |
| **복합 인덱스 + 커서 기반 페이징**  | • 인덱스 기반 일정 응답 시간<br>• 페이지 깊이에 무관                 | • 커서 토큰 관리 로직 필요<br>• 초기 구현 복잡도 증가            |
> ➡️ **최종 선택**  
> • **단일 인덱스 + OFFSET 페이징**으로 우선 배포합니다. 구현 복잡도가 가장 낮고 기존 쿼리 수정을 최소화할 수 있습니다.  
> • 트래픽 증가로 성능 한계에 도달하면 **복합 인덱스 + 커서 기반 페이징**으로 단계적으로 전환합니다.

---

## 3. 사용자 주문 내역 조회
#### 문제가 되는 이유
  - 주문 건수가 늘어나면 OFFSET 기반 페이징에서 스캔 범위가 커져 깊은 페이지일수록 응답 속도가 크게 저하됩니다.
  - `WHERE user_id = ? ORDER BY created_at DESC` 쿼리는 주문 건수가 많을수록 정렬·스캔 비용이 증가합니다.
  - 깊은 페이지 접근 시 추가적인 OFFSET 비용으로 인해 지연이 가중됩니다.

#### 리서치한 기술·솔루션

| 방식                           | 장점                                                     | 단점                                                  |
|------------------------------|--------------------------------------------------------|-----------------------------------------------------|
| **단일 인덱스(user_id) + OFFSET** | • 인덱스 하나라 구현 간단 | • 주문이 많아지면 OFFSET 스캔 비용 급증, 깊은 페이지에서 응답 지연 발생 |
| **복합 인덱스 + 커서 기반 페이징**       | • 필터+정렬 최적화<br>• 일정한 페이징 성능                 | • 커서 토큰 로직 재활용 필요                          |

> ➡️ **최종 선택**  
> • `user_id` 단일 인덱스와 **OFFSET 페이징**을 적용해 초기 개발·테스트 시간을 단축합니다.  
> • 주문량 증가 시 `user_id, created_at, order_id` 복합 인덱스와 **커서 기반 페이징**으로 개선합니다.

---

## 4. 유저 쿠폰 조회

#### 문제가 되는 이유
    - `user_coupon` 테이블에서 `user_id`와 `user_coupon_status` 조건이 인덱스를 타지 않으면 풀 스캔이 발생합니다.
    - 쿠폰 수가 증가할수록 스캔 레코드가 늘어나 응답 지연이 커집니다.

#### 리서치한 기술·솔루션

| 방식                               | 장점                                          | 단점                                    |
|----------------------------------|---------------------------------------------|---------------------------------------|
| **단일 인덱스(user_id)** | • 인덱스 추가가 간단 | • status 조건이 인덱스를 타지 못해 SELECT 범위 넓어짐, 페이징 시 성능 한계 |
| **복합 인덱스(user_id, user_coupon_status)**    | • WHERE+정렬 최적화<br>• 페이징 성능 보장           | • 인덱스 관리 복잡도 소폭 증가         |

> ➡️ **최종 선택**  
> • `(user_id)` 단일 인덱스로 간단히 구현해 신속히 운영 환경에 반영합니다.  
> • 쿠폰 수 증가로 조회 지연이 발생하면 `(user_id, user_coupon_status, created_at)` 복합 인덱스로 교체해 성능을 향상합니다.
